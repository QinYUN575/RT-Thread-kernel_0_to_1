# 从零到一实现 RT-Thread 内核

---

## 裸机系统与多线程系统

### 裸机系统

裸机系统通常分为轮询系统和前后台系统。

#### 轮询系统

**轮询系统**：即系统中需要处理的事务为顺序执行。

存在的问题：

- 只适合顺序执行的代码，当有外部事件驱动时，实时性就会降低。

#### 前后台系统

**前后台系统**：即在轮询系统的基础上加入中断；外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成。

中断我们这里称之为前台，main 函数中的无限循环函我们称之为后台；

中断服务函数中标记事件，确保事件不会丢失，再加上中断可嵌套的功能，大大的提高了程序的实时响应能力；

在大多数中小型项目中，前后台系统运用的好，堪称有操作系统的效果；

### 多线程系统


相比于前后台系统，多线程系统的事件响应也是在中断中完成的，但是事件的处理是在线程中完成的。

在多线程系统中，线程和中断一样也具有优先级，优先级高的线程会被先执行。但一个紧急的事件在中断被标记之后，如果事件对应的优先级足够高，那么对应的事件会马上得到响应；

相比于前后台系统，多线程系统的实时性又被提高了；


轮询、前后台和多线程系统软件模型的区别

| 模型 | 事件响应 | 事件处理 | 特点 |
| --- | --- | --- | --- |
| 轮询系统 | 主程序 | 主程序 | 轮询响应事件、轮询处理事件 |
| 前后台系统 | 中断 | 主函数 | 实时响应事件、轮询处理事件 |
| 多线程系统 | 中断 | 主程序 | 实时响应事件、实时处理事件 |

## 什么是实时操作系统(RTOS)

在从 0 到 1 手写 RT-Thread 之前，先问下自己什么是“实时操作系统(RTOS)”。

实时操作系统的核心即：“实时” + “操作系统”

- 先是“操作系统”： 这里简要说明，即提供任务调度，管理一切下层硬件，为上层软件提供统一，抽象的 API 、中间件的一种软件


> 实际上不管是裸机程序还是 RTOS/多线程系统 程序本质上都是状态转移（状态机的表现）
> 而两者的区别是多线程系统“表现”出的“并发”特性

## 线程的定义与线程切换的实现

> 线程切换实际上就是 CPU 上下文的切换（每个线程有自己的上下文）


## 临界区 && 调度锁

临界区保护

1. 为什么需要临界区：

临界区保护的目的是为了防止共享资源（包括全局变量等）被同时访问

2. 如何进行临界区保护

首先明确发生共享资源访问冲突的两种情况：

- 任务切换时会发生访问冲突
- 终端发生时会发生访问冲突

我们知道任务切换是在 PenSV 中断中完成的，本质上也是发生中断，那么在访问一些可能发送冲突的变量时，将所有可屏蔽中断进行关闭，这样就可以解决资源访问冲突问题。

3. 使用临界区保护的缺点

关闭可屏蔽中断，系统见无法进行任务调度，将使系统的实时性变差

调度锁
